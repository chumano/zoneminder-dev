/*
* Copyright (c) 2017 Liming Shao <lmshao@163.com>
*/

#include "VideoEncoding.h"

//g++ -w main.cpp VideoEncoding.cpp -o main $(pkg-config --cflags --libs libavutil libavformat libavcodec)
int main()
{
    VideoEncoding videoEncoding;

    // Using the .yuv file generated by the VideoDecoder project
    const char *inFile = "../output/Sample_1280x534_yuv420p.yuv";
    const char *outFile = "../output/Sample2.h264";

    videoEncoding.init();

    // Configure AVCodecContext parameters Manually
    videoEncoding.initCodecContext();

    videoEncoding.readFrameProc(inFile, outFile);

    // //get codec for encoding
    // AVCodecContext *codecContext = NULL;
    // AVFrame *frame;
    // AVPacket packet;
    // const AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_H264);
    // if (!codec)
    // {
    //     printf("Failed to find encoder!\n");
    //     return 0;
    // }
    // //alloc codec context
    // codecContext = avcodec_alloc_context3(codec);
    // if (!codecContext)
    // {
    //     printf("Failed to alloc codec context!\n");
    //     return 0;
    // }
    // //set parameters of the video to be encoded
    // codecContext->width = 1280; //equal to the YUV file size
    // codecContext->height = 534;
    // codecContext->bit_rate = 1000000; // 1Mbps
    // codecContext->gop_size = 10;
    // codecContext->time_base = {1, 24};
    // codecContext->framerate = {24, 1};
    // codecContext->max_b_frames = 1;
    // codecContext->pix_fmt = AV_PIX_FMT_YUV420P;
    // //set option (in this case latency)
    // if (codec->id == AV_CODEC_ID_H264)
    // {
    //     av_opt_set(codecContext->priv_data, "tune", "zerolatency", 0);
    // }
    // //Initialize codecContext to use the given Codec
    // if (avcodec_open2(codecContext, codec, 0) < 0)
    // {
    //     printf("Failed to init codecContext!\n");
    //     return 0;
    // }
    // //read frame
    // //open file input and output
    // FILE *yuvfs = fopen(inFile, "rb");
    // FILE *h264fs = fopen(outFile, "wb");
    // if (!yuvfs || !h264fs)
    // {
    //     printf("Failed to open files!\n");
    //     return 0;
    // }
    // //alloc frame
    // frame = av_frame_alloc();
    // //setup frame
    // frame->format = codecContext->pix_fmt;
    // frame->height = codecContext->height;
    // frame->width = codecContext->width;
    // //get bufer from frame
    // if (av_frame_get_buffer(frame, 32) < 0)
    // {
    //     printf("Failed to get buffer!\n");
    //     return 0;
    // }
    // //traverse throught input stream
    // int i = 0;
    // while (!feof(yuvfs))
    // {
    //     // //init packet
    //     av_init_packet(&packet);
    //     packet.data = NULL; // packet data will be allocated by the encoder
    //     packet.size = 0;

    //     // //make frame writable
    //     if (av_frame_make_writable(frame) < 0)
    //     {
    //         printf("Failed to make frame writable!\n");
    //         return 0;
    //     }

    //     // //store data from input stream to frame data
    //     fread(frame->data[0], 1, codecContext->width * codecContext->height, yuvfs);
    //     fread(frame->data[1], 1, codecContext->width * codecContext->height / 4, yuvfs);
    //     fread(frame->data[2], 1, codecContext->width * codecContext->height / 4, yuvfs);

    //     frame->pts = i++;
    //     // //send frame & receive packet from codec (encode video)
    //     avcodec_send_frame(codecContext, frame);
    //     int ret = avcodec_receive_packet(codecContext, &packet);
    //     // //write packet data to output file stream
    //     if (!ret)
    //     {
    //         printf("Write frame %3d (size=%5d)\n", i, packet.size);
    //         fwrite(packet.data, 1, packet.size, h264fs);
    //         av_packet_unref(&packet);
    //     }
    // }

    // //second loop of encoding to check if there any frame left
    // for (;; i++)
    // {
    //     avcodec_send_frame(codecContext, NULL);
    //     int ret = avcodec_receive_packet(codecContext, &packet);
    //     if (ret == 0)
    //     {
    //         printf("Write frame %3d (size=%5d)\n", i, packet.size);
    //         fwrite(packet.data, 1, packet.size, h264fs);
    //         av_packet_unref(&packet);
    //     }
    //     else if (ret == AVERROR_EOF)
    //     {
    //         printf("Completed encoding file!\n");
    //         break;
    //     }
    //     else
    //     {
    //         printf("Error in encoding!\n");
    //         break;
    //     }
    // }

    // //add sequence end code to have a real MPEG file
    // uint8_t encode[] = {0, 0, 1, 0xb7};
    // fwrite(encode, 1, sizeof(encode), h264fs);

    // //close input and output file stream
    // fclose(yuvfs);
    // fclose(h264fs);

    // //free frame
    // av_frame_free(&frame);

    return 1;
}